
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Smart Contract Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../Deploying and Testing.html" />
    
    
    <link rel="prev" href="../../Bottos Node/BCLI.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    Bottos Introduction
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="../../Bottos Basics/Bottos Architecture.html">
            
                <a href="../../Bottos Basics/Bottos Architecture.html">
            
                    
                    Bottos Architecture
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../../Bottos Node/Node Introduction.html">
            
                <a href="../../Bottos Node/Node Introduction.html">
            
                    
                    Bottos Node
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../../Bottos Node/Network Topology.html">
            
                <a href="../../Bottos Node/Network Topology.html">
            
                    
                    Network Topology
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../../Bottos Node/BCLI.html">
            
                <a href="../../Bottos Node/BCLI.html">
            
                    
                    BCLI
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter active" data-level="1.3" data-path="Write smart contract in C++.html">
            
                <a href="Write smart contract in C++.html">
            
                    
                    Smart Contract
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../Deploying and Testing.html">
            
                <a href="../Deploying and Testing.html">
            
                    
                    Deploying and Testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../API/Common REST Interface.html">
            
                <a href="../API/Common REST Interface.html">
            
                    
                    Common REST Interface
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../API/Wallet REST Interface.html">
            
                <a href="../API/Wallet REST Interface.html">
            
                    
                    Wallet REST Interface
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../../Wallet SDK/Wallet SDK.html">
            
                <a href="../../Wallet SDK/Wallet SDK.html">
            
                    
                    Wallet SDK
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../../DApp Development/How to set up the development environment.html">
            
                <a href="../../DApp Development/How to set up the development environment.html">
            
                    
                    DApp Development
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../../DApp Development/Install and Run Bottos.html">
            
                <a href="../../DApp Development/Install and Run Bottos.html">
            
                    
                    Install and Run Bottos
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../../DApp Development/Development and deployment of Smart Contract.html">
            
                <a href="../../DApp Development/Development and deployment of Smart Contract.html">
            
                    
                    Development and deployment of Smart Contract
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../../DApp Development/DApp developing and debugging.html">
            
                <a href="../../DApp Development/DApp developing and debugging.html">
            
                    
                    DApp developing and debugging
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >Smart Contract</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="write-smart-contract-in-c">Write smart contract in C++</h1>
<h1 id="1-compilation-of-contract&#xFF08;cc-version&#xFF09;">1. Compilation of contract&#xFF08;C/C++ version&#xFF09;</h1>
<p>C/C++&apos;s contract compilation tool chain is under following library:</p>
<p><a href="https://github.com/bottos-project/contract-tool-cpp.git" target="_blank">https://github.com/bottos-project/contract-tool-cpp.git</a></p>
<p>This tool is used for compiling C/C++ contracts, generating wasm/wast files, and scanning and generating the abi file. We will describe it in following 2 samples from the library.</p>
<h2 id="1-sample-of-testhelloworld">1. Sample of testHelloWorld</h2>
<p>Put the contract code file put into a directory, and put that directory into the directory of &quot;&#x201C;contract-tool-cpp&quot;, like sample of testHelloWorld.</p>
<p>As you need to compile the contract, go through into the directory of contract, like come into testHelloWorld&apos;s directory, then use the follwing command to compile the contract, while after then the &apos;testHelloWorld.wast&apos; and &apos;testHelloWorld.wasm&apos; will be generated under the same directory:</p>
<pre><code>python ../gentool.py wasm testHelloWorld.cpp
</code></pre><p>Since this sample does not related to abi, we will describe what does the abi file be generated like in following cases.</p>
<h2 id="2-sample-of-testreguser">2. Sample of testRegUser</h2>
<p>Like above case, compile the contract as coming into the directory of &apos;testRegUser&apos; and compiling the contract via using following command:</p>
<pre><code>python ../gentool.py wasm testRegUser.cpp
</code></pre><p>Now we mainly focus on how does the contract abi file be generated. By now, let us introduce what is abi file composed of: </p>
<ul>
<li>structs &#xFF1A;The struct descriptions from scanning, which will be used later.</li>
<li>actions&#xFF1A;The description of contract methods, in which the action_name stands for the name of the function, type stands for the parameters that called by contract&#xFF1B;</li>
<li>tables &#xFF1A;The contract persistence data drovider description, where table_name is the table&apos;s name, index_type is the type of index, key_names and Key_types are the name and type of the key value, and type is the structure definition of the content.</li>
</ul>
<p>The ABI file is generated by scanning the hpp file, in which it tells the scanner specific definition  through comments.</p>
<ul>
<li><p>&quot;//@abi action reguser&quot;&#xFF1A;</p>
<p>  A method reguser is defined, and the corresponding entry parameter is defined as UserInfo;</p>
</li>
<li><p>&quot;//@abi table userinfo:[index_type:string&#xFF0C; &quot;key_names:userName&#xFF0C; key_types:string] &quot;&#xFF1A;</p>
<p>  &#x200B;A table is defined, and the structure of the table content is defined as Userbaseinfo.</p>
</li>
</ul>
<p>Under the Testreguser folder, you can scan the ABI file for the hpp file by using the following command:</p>
<pre><code>python ../gentool testRegUser.hpp
</code></pre><h1 id="2-contracts-editing&#xFF08;cc-version&#xFF09;">2. contract&apos;s editing&#xFF08;C/C++ version&#xFF09;</h1>
<h2 id="21-a-simplest-contract">2.1. A simplest contract</h2>
<p>The entry function of the contract is the start function, and we create a simple contract, that is, when the contract is tuned, print  &quot;Hello World in Start&quot;:</p>
<pre><code>#include &quot;contractcomm.hpp&quot;

int start(char* method) 
{
    myprints(&quot;hello world in start&quot;);

    return 0;
}
</code></pre><p>The  &quot;Contractcomm.hpp&quot; is a common basic interface declaration file. 
Call this contract, and the &quot;Hello World in Start&quot; will be printed in the log of the node:</p>
<pre><code>2018-08-06 16:05:20 [INF] vm/wasm/exec/env_func.go:390 prints(): VM: func prints: hello world in start
</code></pre><h2 id="22-gets-the-method-that-invokes-the-contract">2.2. Gets the method that invokes the contract</h2>
<p>As calling a contract, we need to specify a specific method for calling the contract, that is, the following &quot;method&quot; parameter &quot;Test_method&quot;:</p>
<pre><code>{&quot;version&quot;:1, &quot;cursor_num&quot;:28,&quot;cursor_label&quot;:3745260307,&quot;lifetime&quot;:15270819998,&quot;sender&quot;:&quot;example&quot;, &quot;contract&quot;:&quot;example&quot;, &quot;method&quot;:&quot;test_method&quot;, &quot;param&quot;:&quot;&quot;, &quot;sig_alg&quot;:1, &quot;signature&quot;:&quot;&quot;}
</code></pre><p>This method is passed into the contract through the entry of the start function, that is, the following method parameter, then we add the statement to print the parameter in the contract:</p>
<pre><code>#include &quot;contractcomm.hpp&quot;

int start(char* method) 
{
    myprints(&quot;hello world in start&quot;);
    myprints(method);

    return 0;
}
</code></pre><p>We construct a transaction that sets method to a specific string, the following &quot;Test_method&quot;: (The exact value of the signature is omitted here, the same below)</p>
<pre><code>{&quot;version&quot;:1, &quot;cursor_num&quot;:28,&quot;cursor_label&quot;:3745260307,&quot;lifetime&quot;:15270819998,&quot;sender&quot;:&quot;example&quot;, &quot;contract&quot;:&quot;example&quot;, &quot;method&quot;:&quot;test_method&quot;, &quot;param&quot;:&quot;&quot;, &quot;sig_alg&quot;:1, &quot;signature&quot;:&quot;&quot;}
</code></pre><p>From calling this contract, there will be the following log output: Print the set  &quot;method&quot; parameter, that is, &quot;Test_method&quot;:</p>
<pre><code>2018-08-07 14:40:22 [INF] vm/wasm/exec/env_func.go:412 prints(): VM: func prints: hello word in start

2018-08-07 14:40:22 [INF] vm/wasm/exec/env_func.go:412 prints(): VM: func prints: test_method
</code></pre><p>We can provide different contract implementations in the contract according to method, that is, by comparing the method parameters and then going to different branch branches, such as the  &quot;add&quot; and  &quot;Del&quot; methods provided in the following contracts:</p>
<pre><code>#include &quot;contractcomm.hpp&quot;
#include &quot;string.hpp&quot;

int start(char* method) 
{
    myprints(&quot;hello word in start&quot;);
    myprints(method );

    if (0 == strcmp(&quot;add&quot;, method))
    {
        myprints(&quot;it is method add&quot;);
    }
    else if (0 == strcmp(&quot;del&quot;, method))
    {
        myprints(&quot;it is method del&quot;);
    }

    return 0;
}
</code></pre><h2 id="23-gets-the-call-contract-parameter">2.3. Gets the call contract parameter</h2>
<p>When calling a contract, in addition to specifying the method of calling the contract, you also need to bring the corresponding parameters, that is, the following  &quot;param&quot; parameter:</p>
<pre><code>{&quot;version&quot;:1, &quot;cursor_num&quot;:28,&quot;cursor_label&quot;:3745260307,&quot;lifetime&quot;:15270819998,&quot;sender&quot;:&quot;example&quot;, &quot;contract&quot;:&quot;example&quot;, &quot;method&quot;:&quot;test_method&quot;, &quot;param&quot;:&quot;&quot;, &quot;sig_alg&quot;:1, &quot;signature&quot;:&quot;&quot;}
</code></pre><p>This parameter can be obtained through the  &quot;Getparam&quot; interface in the contract, for example:</p>
<pre><code>#include &quot;contractcomm.hpp&quot;
#define ERROR_PARAM (-1)

int start(char* method) 
{
    char param[PARAM_MAX_LEN];
    uint32_t paramLen = 0;    

    paramLen = getParam(param, PARAM_MAX_LEN);

    if (0 == paramLen) 
    {
        myprints(&quot;paramLen is 0, error&quot;);
        return ERROR_PARAM;
    }

    myprints(&quot;paramLen is:&quot;);
    printi(paramLen);    
    myprints(&quot;param detail:&quot;);
    for(int i = 0;i&lt;paramLen;i++)
    {
        printi(param[i]);
    }

    return 0;
}
</code></pre><p>We construct a transaction: The parameter is a value that is serialized by Messagepack, for example, we need to pass a serialized parameter to [97,98,99], convert its serialized value into a 16-binary string: &quot;616263&quot;, and then fill in the Param:</p>
<pre><code>{&quot;version&quot;:1, &quot;cursor_num&quot;:28,&quot;cursor_label&quot;:3745260307,&quot;lifetime&quot;:15270819998,&quot;sender&quot;:&quot;example&quot;, &quot;contract&quot;:&quot;example&quot;, &quot;method&quot;:&quot;test_method&quot;, &quot;param&quot;:&quot;616263&quot;, &quot;sig_alg&quot;:1, &quot;signature&quot;:&quot;&quot;}
</code></pre><p>By calling this contract, there will be the following log output, that is, you can get the value after serialization to [97,98,99] in the contract:</p>
<pre><code>2018-08-08 17:25:26 [INF] vm/wasm/exec/env_func.go:431 prints(): VM: func prints: paramLen is:

2018-08-08 17:25:26 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:example, method:test_method, func printi: 3

2018-08-08 17:25:26 [INF] vm/wasm/exec/env_func.go:431 prints(): VM: func prints: param detail:

2018-08-08 17:25:26 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:example, method:test_method, func printi: 97

2018-08-08 17:25:26 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:example, method:test_method, func printi: 98

2018-08-08 17:25:26 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:example, method:test_method, func printi: 99
</code></pre><h2 id="24-storage-and-reading-of-contract-data">2.4. Storage and reading of contract data</h2>
<p>In order to facilitate unified access to data, we require that the data to be saved by the contract be serialized with Messagepack, and that the read data be deserialized accordingly to obtain the original data.</p>
<p>Here we define a structure for testing:</p>
<pre><code>struct TestStruct {
    uint32_t valueA;
    uint32_t valueB;
};
</code></pre><p>We pass param to a parameter of type teststruct, where the values of the fields are filled in 1 and 2 respectively, first serialized, obtained [220,0,2,206,0,0,0,1,206,0,0,0,2], and converted into a 16-binary string: &quot; Dc0002ce00000001ce00000002 &quot;, we fill in the Param in the transaction with this value:</p>
<pre><code>{&quot;version&quot;:1, &quot;cursor_num&quot;:28,&quot;cursor_label&quot;:3745260307,&quot;lifetime&quot;:15270819998,&quot;sender&quot;:&quot;example&quot;, &quot;contract&quot;:&quot;example&quot;, &quot;method&quot;:&quot;test_method&quot;, &quot;param&quot;:&quot;dc0002ce00000001ce00000002&quot;, &quot;sig_alg&quot;:1, &quot;signature&quot;:&quot;&quot;}
</code></pre><p>We are in the contract to reverse the incoming parameters:</p>
<pre><code>#include &quot;contractcomm.hpp&quot;
#define ERROR_PARAM (-1)
#define ERROR_UNPACK (-2)

struct TestStruct {
    uint32_t valueA;
    uint32_t valueB;
};


static bool unpack_struct(MsgPackCtx *ctx, TestStruct *info)
{    
    uint32_t size = 0;

    if (!unpack_array(ctx, &amp;size)) return false; 
    if (2 != size) return false;

    if (!unpack_u32(ctx, &amp;info-&gt;valueA)) return false; 
    if (!unpack_u32(ctx, &amp;info-&gt;valueB)) return false; 

    return true;
}

static bool pack_struct(MsgPackCtx *ctx, TestStruct *info)
{    
    if (!pack_array16(ctx, 2)) return false;

    if (!pack_u32(ctx, info-&gt;valueA)) return false; 
    if (!pack_u32(ctx, info-&gt;valueB)) return false; 

    return true;
}

int start(char* method) 
{
    char param[PARAM_MAX_LEN];
    uint32_t paramLen = 0;    

    paramLen = getParam(param, PARAM_MAX_LEN);

    if (0 == paramLen) 
    {
        myprints(&quot;paramLen is 0, error&quot;);
        return ERROR_PARAM;
    }

    MsgPackCtx ctx;
    msgpack_init(&amp;ctx, (char*)param, paramLen);

    TestStruct testStruct;
    bool suc = unpack_struct(&amp;ctx, &amp;testStruct);
    if (!suc)
    {
        myprints(&quot;unpack struct error&quot;);        
        return ERROR_UNPACK;
    }

    myprints(&quot;data from input param:&quot;);
    printi(testStruct.valueA);
    printi(testStruct.valueB);

    return 0;
}
</code></pre><p>By calling this contract, we can see that the structural body inside correctly gets the parameters set when called, 1 and 2, respectively:</p>
<pre><code>2018-08-08 18:20:00 [INF] vm/wasm/exec/env_func.go:431 prints(): VM: func prints: data from input param:

2018-08-08 18:20:00 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:example, method:test_method, func printi: 1

2018-08-08 18:20:00 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:example, method:test_method, func printi: 2
</code></pre><p>We rewrite this data and save it through the Setbinvalue interface, then read it out through Getbinvalue, and then deserialize to get the real data:</p>
<pre><code>#include &quot;contractcomm.hpp&quot;
#define ERROR_PARAM (-1)
#define ERROR_UNPACK (-2)
#define ERROR_SAVE_DB (-3)
#define ERROR_READ_DB (-4)
#define ERROR_CONTRACT_NAME (-5)

struct TestStruct {
    uint32_t valueA;
    uint32_t valueB;
};

static bool unpack_struct(MsgPackCtx *ctx, TestStruct *info)
{    
    uint32_t size = 0;

    if (!unpack_array(ctx, &amp;size)) return false; 
    if (2 != size) return false;

    if (!unpack_u32(ctx, &amp;info-&gt;valueA)) return false; 
    if (!unpack_u32(ctx, &amp;info-&gt;valueB)) return false; 

    return true;
}

static bool pack_struct(MsgPackCtx *ctx, TestStruct *info)
{    
    if (!pack_array16(ctx, 2)) return false;

    if (!pack_u32(ctx, info-&gt;valueA)) return false; 
    if (!pack_u32(ctx, info-&gt;valueB)) return false; 

    return true;
}

int start(char* method) 
{
    char param[PARAM_MAX_LEN];
    uint32_t paramLen = 0;    

    paramLen = getParam(param, PARAM_MAX_LEN);
    if (0 == paramLen) 
    {
        myprints(&quot;paramLen is 0, error&quot;);
        return ERROR_PARAM;
    }

    /* Reverse the param of the order */
    MsgPackCtx ctx;
    msgpack_init(&amp;ctx, (char*)param, paramLen);

    TestStruct testStruct;
    bool suc = unpack_struct(&amp;ctx, &amp;testStruct);
    if (!suc)
    {
        myprints(&quot;unpack struct error&quot;);

        return ERROR_UNPACK;
    }

    myprints(&quot;data from input param:&quot;);
    printi(testStruct.valueA);
    printi(testStruct.valueB);

    /* Rewrite fields to 3, 4 */
    testStruct.valueA = 3;
    testStruct.valueB = 4;

    /* Serialization of operations */
    msgpack_init(&amp;ctx, (char*)param, PARAM_MAX_LEN);
    suc = pack_struct(&amp;ctx, &amp;testStruct);
    if (!suc)
    {
        myprints(&quot;pack struct error&quot;);        
        return ERROR_UNPACK;
    }

    char tableName[] = &quot;testTableName&quot;;
    char keyName[] = &quot;testKeyName&quot;;

    /* Saves the calling interface */
    uint32_t handleResult = setBinValue(tableName, strlen(tableName), keyName, strlen(keyName), ctx.buf, ctx.pos);
    if (0 == handleResult)
    {
        myprints(&quot;save to db error&quot;);        
        return ERROR_SAVE_DB;
    }

    char contractname[STR_ARRAY_LEN(USER_NAME_MAX_LEN)];   
    uint32_t contractNameLen = getCtxName(contractname, STR_ARRAY_LEN(USER_NAME_MAX_LEN));
    if (0 == contractNameLen)
    {
        myprints(&quot;contract name error&quot;);        
        return ERROR_CONTRACT_NAME;
    }

    /* The calling interface gets the value that was just saved */
    handleResult = getBinValue(contractname, contractNameLen, tableName, strlen(tableName), keyName, strlen(keyName), param, PARAM_MAX_LEN);
    if (0 == handleResult)
    {
        myprints(&quot;read from db error&quot;);        
        return ERROR_READ_DB;
    }

    /* Reverse serialization of operations */
    msgpack_init(&amp;ctx, (char*)param, handleResult);
    suc = unpack_struct(&amp;ctx, &amp;testStruct);
    if (!suc)
    {
        myprints(&quot;unpack struct error&quot;);        
        return ERROR_UNPACK;
    }

    myprints(&quot;data from db:&quot;);
    printi(testStruct.valueA);
    printi(testStruct.valueB);   

    return 0;
}
</code></pre><p>Call this contract again with the following trades (that is, input structures, fields 1, 2, respectively):</p>
<pre><code>{&quot;version&quot;:1, &quot;cursor_num&quot;:28,&quot;cursor_label&quot;:3745260307,&quot;lifetime&quot;:15270819998,&quot;sender&quot;:&quot;example&quot;, &quot;contract&quot;:&quot;example&quot;, &quot;method&quot;:&quot;test_method&quot;, &quot;param&quot;:&quot;dc0002ce00000001ce00000002&quot;, &quot;sig_alg&quot;:1, &quot;signature&quot;:&quot;&quot;}
</code></pre><p>As you can see from the log, the fields obtained to the input are 1, 2, which are overwritten to 3, 4, and then saved, and the expected values can still be obtained after the last read is deserialized, that is, the fields are 3 and 4, respectively:</p>
<pre><code>2018-08-08 18:38:34 [INF] vm/wasm/exec/env_func.go:431 prints(): VM: func prints: data from input param:

2018-08-08 18:38:34 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:example, method:test_method, func printi: 1

2018-08-08 18:38:34 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:example, method:test_method, func printi: 2

......

2018-08-08 18:38:34 [INF] vm/wasm/exec/env_func.go:431 prints(): VM: func prints: data from db:

2018-08-08 18:38:34 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:example, method:test_method, func printi: 3

2018-08-08 18:38:34 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:example, method:test_method, func printi: 4
</code></pre><h2 id="25-invoking-other-contracts">2.5. Invoking other contracts</h2>
<p>The following is a compute contract that currently implements the Add method, which calculates the and of two parameters:</p>
<pre><code>#include &quot;contractcomm.hpp&quot;
#include &quot;string.hpp&quot;

#define ERROR_PARAM (-1)
#define ERROR_UNPACK (-2)
#define ERROR_INVALID_METHOD (-3)

struct TestStruct {
    uint32_t valueA;
    uint32_t valueB;
};

static bool unpack_struct(MsgPackCtx *ctx, TestStruct *info)
{    
    uint32_t size = 0;

    if (!unpack_array(ctx, &amp;size)) return false; 
    if (2 != size) return false;

    if (!unpack_u32(ctx, &amp;info-&gt;valueA)) return false; 
    if (!unpack_u32(ctx, &amp;info-&gt;valueB)) return false; 

    return true;
}

static bool pack_struct(MsgPackCtx *ctx, TestStruct *info)
{ 
    if (!pack_array16(ctx, 2)) return false;

    if (!pack_u32(ctx, info-&gt;valueA)) return false; 
    if (!pack_u32(ctx, info-&gt;valueB)) return false; 

    return true;
}

int start(char* method) 
{
    if (0 == strcmp(&quot;add&quot;, method))
    {
        char param[PARAM_MAX_LEN];
        uint32_t paramLen = 0;    

        /* Get the parameters from input */
        paramLen = getParam(param, PARAM_MAX_LEN);

        if (0 == paramLen) 
        {
            myprints(&quot;paramLen is 0, error&quot;);
            return ERROR_PARAM;
        }

        /* Deserialize parameters to get raw data */
        MsgPackCtx ctx;
        msgpack_init(&amp;ctx, (char*)param, paramLen);
        TestStruct testStruct;
        bool suc = unpack_struct(&amp;ctx, &amp;testStruct);
        if (!suc)
        {
            myprints(&quot;unpack struct error&quot;);

            return ERROR_UNPACK;
        }

        printi(testStruct.valueA);
        printi(testStruct.valueB);

        /* Print the and of two parameters */        
        myprints(&quot;add result is:&quot;);
        printi(testStruct.valueA + testStruct.valueB);
    }
    else
    {
        myprints(&quot;invalid method&quot;);

        return ERROR_INVALID_METHOD;
    }

    return 0;
}
</code></pre><p>Then we write a contract in which the above calculation contract is called, which is passed to the above calculation contract two parameters, in the calculation contract to calculate the and of these two parameters: (assuming that the above calculation contract has been deployed on the Calccontract account)</p>
<pre><code>#include &quot;contractcomm.hpp&quot;
#define ERROR_UNPACK  (-1)
#define ERROR_CALLTRX (-2)

struct TestStruct {
    uint32_t valueA;
    uint32_t valueB;
};

static bool unpack_struct(MsgPackCtx *ctx, TestStruct *info)
{    
    uint32_t size = 0;

    if (!unpack_array(ctx, &amp;size)) return false; 
    if (2 != size) return false;

    if (!unpack_u32(ctx, &amp;info-&gt;valueA)) return false; 
    if (!unpack_u32(ctx, &amp;info-&gt;valueB)) return false; 

    return true;
}

static bool pack_struct(MsgPackCtx *ctx, TestStruct *info)
{    
    if (!pack_array16(ctx, 2)) return false;

    if (!pack_u32(ctx, info-&gt;valueA)) return false; 
    if (!pack_u32(ctx, info-&gt;valueB)) return false; 

    return true;
}

int start(char* method) 
{
    char param[PARAM_MAX_LEN];
    TestStruct testStruct;

    testStruct.valueA = 3;
    testStruct.valueB = 4;    

    /* Serialization of operations */
    MsgPackCtx ctx;
    msgpack_init(&amp;ctx, (char*)param, PARAM_MAX_LEN);
    bool suc = pack_struct(&amp;ctx, &amp;testStruct);
    if (!suc)
    {
        myprints(&quot;pack struct error&quot;);        
        return ERROR_UNPACK;
    }  

    /* Define the name of the contract to call, and the method name */
    char *callContractName = &quot;calccontract&quot;;
    char *callMethod = &quot;add&quot;;

    /* Invoke the contract */
    uint32_t callResult = callTrx(callContractName , strlen(callContractName), callMethod, strlen(callMethod), ctx.buf , ctx.pos);
    if (0 != callResult)
    {
        myprints(&quot;call trx error&quot;);        
        return ERROR_CALLTRX;
    }

    myprints(&quot;call trx succed&quot;);       

    return 0;
}
</code></pre><p>Let&apos;s call this contract above and there will be the following log:</p>
<pre><code>2018-08-09 12:00:34 [INF] vm/wasm/exec/env_func.go:431 prints(): VM: func prints: call trx succed

2018-08-09 12:00:34 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:calccontract, method:add, func printi: 3

2018-08-09 12:00:34 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:calccontract, method:add, func printi: 4

2018-08-09 12:00:34 [INF] vm/wasm/exec/env_func.go:431 prints(): VM: func prints: add result is:

2018-08-09 12:00:34 [INF] vm/wasm/exec/env_func.go:405 printi(): VM: from contract:calccontract, method:add, func printi: 7
</code></pre><h2 id="26-attachment-1-interface-function-for-shared-invocation">2.6. Attachment 1: interface function for shared invocation</h2>
<ul>
<li><p>void prints(char *str, uint32_t len);</p>
<p>Function: Print string</p>
<p>Parameter description&#xFF1A;</p>
<p>| Parameter | Type     | Description                       |
| --------- | -------- | --------------------------------- |
| str       | char*    | Character Pointer to print        |
| len       | uint32_t | The length of the string to print |</p>
</li>
</ul>
<ul>
<li><p>void printi(uint64_t param);</p>
<p>  | Parameter | Type     | Description          |
  | --------- | -------- | -------------------- |
  | param     | uint64_t | The integer to print |</p>
</li>
</ul>
<ul>
<li><p>uint32_t setBinValue(char<em> object, uint32_t objLen, char</em> key, uint32_t keyLen, char *value, uint32_t valLen);</p>
<p>Function: Save data to the chain</p>
<p>Parameter description&#xFF1A;</p>
<p>| Parameter | Type     | Description                                                  |
| --------- | -------- | ------------------------------------------------------------ |
| object    | char<em>    | The table name corresponding to the saved dat                |
| objLen    | uint32_t | The length of the table name corresponding to the saved data |
| key       | char</em>    | Key value name of the saved data                             |
| keyLen    | uint32_t | The key value name length of the saved data                  |
| value     | char*    | Data to be saved                                             |
| valLen    | uint32_t | Length of data to be saved                                   |</p>
<p>Return value: Saved data length</p>
</li>
<li><p>uint32_t getBinValue(char<em> contract, uint32_t contractLen, char</em> object, uint32_t objLen, char<em> key, uint32_t keyLen, char </em>valueBuf, uint32_t valueBufLen);</p>
<p>Function: Get data from the chain</p>
<p>Parameter description&#xFF1A;</p>
<p>| Parameter   | Type     | Description                                                        |
| ----------- | -------- | ------------------------------------------------------------------ |
| contract    | char<em>    | The contract name corresponding to the obtained data               |
| contractLen | uint32_t | The length of the contract name corresponding to the obtained data |
| object      | char</em>    | Gets the table name corresponding to the data                      |
| objLen      | uint32_t | Gets the length of the table name corresponding to the data        |
| key         | char<em>    | Gets the key value name of the data                                |
| keyLen      | uint32_t | Gets the length of the key value name of the data                  |
| valueBuf    | char</em>    | Buffers used to store data                                         |
| valueBufLen | uint32_t | The length of the buffer used to store the data                    |</p>
<p>Return value: The length of the obtained data</p>
</li>
<li><p>uint32_t removeBinValue(char<em> object, uint32_t objLen, char</em> key, uint32_t keyLen);</p>
<p>Function: Remove data from the chain</p>
<p>Parameter description&#xFF1A;</p>
<p>| Parameter | Type     | Description                                                   |
| --------- | -------- | ------------------------------------------------------------- |
| object    | char<em>    | The table name corresponding to the deleted data              |
| objLen    | uint32_t | The length of the table name corresponding to the deleted dat |
| key       | char</em>    | The key value name of the deleted data                        |
| keyLen    | uint32_t | The length of the key value name of the deleted data          |</p>
<p>Return value: The length of the deleted data</p>
</li>
<li><p>uint32_t getParam(char *param, uint32_t bufLen);</p>
<p>Function: Gets the parameter when the contract is invoked</p>
<p>Parameter description&#xFF1A;</p>
<p>| Parameter | Type     | Description                  |
| --------- | -------- | ---------------------------- |
| param     | char*    | Buffer for storing parameter |
| bufLen    | uint32_t | Buffer for storing parameter |</p>
<p>Return value: The length of the parameter obtained</p>
</li>
<li><p>bool callTrx(char <em>contract , uint32_t contractLen, char </em>method , uint32_t methodLen,  char *buf , uint32_t bufLen );</p>
<p>Function: Invoke other contracts (asynchronous mode)</p>
<p>Parameter description&#xFF1A;</p>
<p>| Parameter   | Type     | Description                                                |
| ----------- | -------- | ---------------------------------------------------------- |
| contract    | char<em>    | The name of the contract to invoke                         |  | contractLen |
| contractLen | uint32_t | The length of the name of the contract to invoke           |
| method      | char</em>    | The method name to invoke the contract                     |
| methodLen   | uint32_t | The length of the method name to invoke the contract       |
| buf         | char*    | Call the contract incoming parameter                       |
| bufLen      | uint32_t | The length of the parameter passed by the calling contract |</p>
<p>Return value&#xFF1A;true: success&#xFF0C;false: failure</p>
</li>
<li><p>uint32_t getCtxName(char *str , uint32_t len);</p>
<p>Function: Get contract name</p>
<p>Parameter description&#xFF1A;</p>
<p>| Parameter | Type     | Description                                            |
| --------- | -------- | ------------------------------------------------------ |
| str       | char*    | Buffer for storing contract name                       |
| len       | uint32_t | The length of the buffer that stores the contract name |</p>
<p>Return value: The length of the account name obtained</p>
</li>
<li><p>uint32_t  getSender(char *str , uint32_t len);</p>
<p>Function: Gets the name of the account that invokes the current contract</p>
<p>Parameter description&#xFF1A;</p>
<p>| Parameter | Type     | Description                                           |
| --------- | -------- | ----------------------------------------------------- |
| str       | char*    | Buffer for storing account names                      |
| len       | uint32_t | The length of the buffer that stores the account name |</p>
<p>Return value: The length of the account name obtained</p>
</li>
<li><p>bool isAccountExist(char *name&#xFF0C; uint32_t nameLen);</p>
<p>function: Check if the account exists</p>
<p>Parameter description&#xFF1A;</p>
<p>| Parameter | Type     | Description                             |
| --------- | -------- | --------------------------------------- |
| name      | char*    | The account you want to check           |
| nameLen   | uint32_t | The length of the account name to check |</p>
<p>Return value&#xFF1A;true: exists&#xFF0C;false: not exists</p>
</li>
</ul>
<h2 id="27-serialization-of-the-attached-2messagepack">2.7. Serialization of the attached 2:messagepack</h2>
<h3 id="271-overview">2.7.1 Overview</h3>
<p>In order to facilitate the parameter transmission when the contract is invoked, and to read the persistent data of the contract, we have selected Messagepack this lightweight codec method, detailed specification reference:</p>
<p><a href="https://msgpack.org/" target="_blank">https://msgpack.org/</a></p>
<p><a href="https://github.com/msgpack/msgpack/blob/master/spec.md" target="_blank">https://github.com/msgpack/msgpack/blob/master/spec.md</a></p>
<p>In addition, we have made some tailoring to the characteristics of the contract data.</p>
<ol>
<li><p>Basic Type&#xFF1A;Supports uint8&#x3001;uint16&#x3001;uint32&#x3001;uint64&#x3001;array16&#x3001;bin16&#x3001;str16Type&#xFF1B;</p>
</li>
<li><p>Variable length data: For example strtype,messagepack the original specification according to the length of the string fill in the length of bytes, there are 1, 2, 4 byte length of the difference, after the transformation of the default use of 2 bytes (str16), Bintype and ArrayType is also, that is, only support Bin16, ARRAY16 this type;</p>
</li>
<li><p>Structure: The structure body is encapsulated in the form of array, the ARRAY16 head is written first, and then the fields are encoded in turn.</p>
</li>
</ol>
<p>Sample(C)&#xFF1A;</p>
<pre><code>struct user_login {
    char user_name[USER_NAME_MAX_LEN];
    uint32_t random_num;
};

user_login login;
strcpy(login.user_name, &quot;testuser&quot;);
login.random_num = 99;

pack_array16(&amp;ctx, 2);
pack_str16(&amp;ctx, login-&gt;user_name, strlen(login-&gt;user_name));
pack_u32(&amp;ctx, login-&gt;random_num);
</code></pre><p>Encoding result&#xFF1A;</p>
<pre><code>0xdc, 0x00, 0x02, 0xda, 0x00, 0x08, 0x74, 0x65, 0x73, 0x74, 0x75, 0x73, 0x65, 0x72, 0xce, 0x00, 0x00, 0x00, 0x63
</code></pre><h3 id="272-coding-specification">2.7.2 Coding specification</h3>
<p><strong>Types</strong></p>
<ul>
<li><strong>Integer</strong> represents an integer</li>
<li>Raw<ul>
<li><strong>String</strong> extending Raw type represents a UTF-8 string</li>
<li><strong>Binary</strong> extending Raw type represents a byte array</li>
</ul>
</li>
<li><strong>Array</strong> represents a sequence of objects</li>
</ul>
<p><strong>Format</strong></p>
<table>
<thead>
<tr>
<th>format name</th>
<th>first byte (in binary)</th>
<th>first byte (in hex)</th>
</tr>
</thead>
<tbody>
<tr>
<td>bin16</td>
<td>11000101</td>
<td>0xc5</td>
</tr>
<tr>
<td>uint8</td>
<td>11001100</td>
<td>0xcc</td>
</tr>
<tr>
<td>uint16</td>
<td>11001101</td>
<td>0xcd</td>
</tr>
<tr>
<td>uint32</td>
<td>11001110</td>
<td>0xce</td>
</tr>
<tr>
<td>uint64</td>
<td>11001111</td>
<td>0xcf</td>
</tr>
<tr>
<td>str16</td>
<td>11011010</td>
<td>0xda</td>
</tr>
<tr>
<td>array16</td>
<td>11011100</td>
<td>0xdc</td>
</tr>
</tbody>
</table>
<p><strong>Notation in diagrams</strong></p>
<pre><code>one byte:
+--------+
|        |
+--------+

a variable number of bytes:
+========+
|        |
+========+

variable number of objects stored in MessagePack format:
+~~~~~~~~~~~~~~~~~+
|                 |
+~~~~~~~~~~~~~~~~~+
</code></pre><p><strong>int format family</strong></p>
<p>Int format family stores an integer in 2, 3, 5, or 9 bytes.</p>
<pre><code>uint 32 stores a 32-bit big-endian unsigned integer
+--------+--------+--------+--------+--------+
|  0xce  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|
+--------+--------+--------+--------+--------+

uint 64 stores a 64-bit big-endian unsigned integer
+--------+--------+--------+--------+--------+--------+--------+--------+--------+
|  0xcf  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|
+--------+--------+--------+--------+--------+--------+--------+--------+--------+
</code></pre><p><strong>str format family</strong></p>
<p>Str format family stores a byte array in 3 bytes of extra bytes in addition to the size of the byte array.</p>
<pre><code>str 16 stores a byte array whose length is upto (2^16)-1 bytes:
+--------+--------+--------+========+
|  0xda  |ZZZZZZZZ|ZZZZZZZZ|  data  |
+--------+--------+--------+========+

where
* ZZZZZZZZ_ZZZZZZZZ is a 16-bit big-endian unsigned integer which represents N
* N is the length of data
</code></pre><p><strong>bin format family</strong></p>
<p>Bin format family stores a byte array in 3 bytes of extra bytes in addition to the size of the byte array.</p>
<pre><code>bin 16 stores a byte array whose length is upto (2^16)-1 bytes:
+--------+--------+--------+========+
|  0xc5  |YYYYYYYY|YYYYYYYY|  data  |
+--------+--------+--------+========+

where
* YYYYYYYY_YYYYYYYY is a 16-bit big-endian unsigned integer which represents N
* N is the length of data
</code></pre><p><strong>array format family</strong></p>
<p>Array format family stores a sequence of elements in 3 bytes of extra bytes in addition to the elements.</p>
<pre><code>array 16 stores an array whose length is upto (2^16)-1 elements:
+--------+--------+--------+~~~~~~~~~~~~~~~~~+
|  0xdc  |YYYYYYYY|YYYYYYYY|    N objects    |
+--------+--------+--------+~~~~~~~~~~~~~~~~~+

where
* YYYYYYYY_YYYYYYYY is a 16-bit big-endian unsigned integer which represents N
    N is the size of a array
</code></pre><p><strong>Serialization: type to format conversion</strong></p>
<p>MessagePack serializers convert MessagePack types into formats as following:</p>
<table>
<thead>
<tr>
<th>source types</th>
<th>output format</th>
</tr>
</thead>
<tbody>
<tr>
<td>Integer</td>
<td>int format family (positive fixint uint 8/16/32/64)</td>
</tr>
<tr>
<td>String</td>
<td>str format family (str16)</td>
</tr>
<tr>
<td>Binary</td>
<td>bin format family (bin16)</td>
</tr>
<tr>
<td>Array</td>
<td>array format family (array16)</td>
</tr>
</tbody>
</table>
<p><strong>Deserialization: format to type conversion</strong></p>
<p>MessagePack deserializers convert MessagePack formats into types as following:</p>
<table>
<thead>
<tr>
<th>source formats</th>
<th>output type</th>
</tr>
</thead>
<tbody>
<tr>
<td>positive fixint,uint 8/16/32/64</td>
<td>Integer</td>
</tr>
<tr>
<td>str16</td>
<td>String</td>
</tr>
<tr>
<td>bin16</td>
<td>Binary</td>
</tr>
<tr>
<td>array16</td>
<td>Array</td>
</tr>
</tbody>
</table>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../../Bottos Node/BCLI.html" class="navigation navigation-prev " aria-label="Previous page: BCLI">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../Deploying and Testing.html" class="navigation navigation-next " aria-label="Next page: Deploying and Testing">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Smart Contract","level":"1.3","depth":1,"next":{"title":"Deploying and Testing","level":"1.3.1","depth":2,"path":"Smart Contract/Deploying and Testing.md","ref":"Smart Contract/Deploying and Testing.md","articles":[]},"previous":{"title":"BCLI","level":"1.2.2","depth":2,"path":"Bottos Node/BCLI.md","ref":"Bottos Node/BCLI.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-lunr","livereload"],"root":".","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"livereload":{},"highlight":{},"search":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"gitbook":"*","description":"Bottos Development files","theme-default":{"showLevel":true}},"file":{"path":"Smart Contract/Development/Write smart contract in C++.md","mtime":"2018-11-14T08:13:47.239Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-11-14T09:34:16.926Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

